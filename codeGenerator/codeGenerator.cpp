#include "codeGenerator.h"

using namespace std;

int CodeGenerator::console_state_machine_code(){
    //Opens the file
    ofstream code_file;
    string code;
    code_file.open(code_file_name, ios_base::app);

    //Initializes a state machine var
    code = "//State Machine state\n";
    code += "int state = 0;\n\n";

    //Opens the state machine
    code += "switch(state){\n";

    //writes to the file
    code_file << code;

    //You need to close the file before call a function that opens it
    code_file.close();

    //For each state, calls the linear_function to write it's respective functions
    for(int i = 0; i < this->number_of_states; i++){

        code_file.open(code_file_name, ios_base::app);

        //Another state
        code = "\n	case '" + to_string(i) + "':\n";

        //writes to the file
        code_file << code;

        //You need to close the file before call a function that opens it
        code_file.close();

        //Write the linear code state
        this->console_linear_function(this->states_functions[i]);
    }

    //Opens the file
    code_file.open(code_file_name, ios_base::app);

    //Close the switch
    code = "\n    }\n";

    //writes to the file
    code_file << code;
    //You need to close the file before call a function that opens it
    code_file.close();

    return 0;
}

int CodeGenerator::console_start(){

    //Starts the generated code file
    ofstream code_file;
    string code;
    ifstream data_base;
    string s_modules;
    string input_modules = "";
    code_generator_struct data_for_modules;

    code_file.open(code_file_name);

    code = "//This code was generated by codeGenerator\n";
    //Fist, all the includes should be put here
    code = code + "#include<iostream>\n";

    //Writes to file
    code_file << code;
    code_file.close();

    //Writes the modules chosen by the user
    data_base.open(modules_data_base_path.c_str());
    if(data_base){
       for(int i = 0; i < this->modules_ids.size(); i++){
            data_base.seekg((this->modules_ids[i]-1)*sizeof(code_generator_struct), ios_base::beg);
            //data_base.read((char*)data_for_modules, sizeof(data_for_modules));
            cout << data_for_modules.name;
            cin >> data_for_modules.name;
            s_modules = data_for_modules.name;
            input_modules = input_modules + "\n";
            input_modules = input_modules + "#include<" +s_modules + ".h>";
            s_modules = "";
            }
        data_base.close();
        cout << input_modules << endl;
        code_file.open(code_file_name, ios_base::app);
        code_file << input_modules + "\n\n";
        code_file.close();
    }
    else{
        cout << "Error - Modules data base cannot be opened." << endl;
            return -1;
    }

    code_file.open(code_file_name, ios_base::app);

    //Namespace std, default in c++ applications
    code = "using namespace std;\n\n";
    //Starts the main function
    code = code + "int main(){\n";
    //Code....

    //Writes to file
    code_file << code;
    code_file.close();
}

void CodeGenerator::finish(){

    //Starts the generated code file
    ofstream code_file;
    string code;

    //Open the file to append
    code_file.open(code_file_name, ios_base::app);

    //Writes the main return and closes the code
    code = "\n";
    code = code + "	return 0;\n";
    code = code + "}";

    //Writes to file
    code_file << code;
    code_file.close();
}

void CodeGenerator::console_create_functions_database(){

    CodeGenerator code_gen;
    code_generator_struct new_m; //Struct that receives new function data
    FILE *data_base; //Pointer to data_base file
    string param_type;
    string param_name;
    cout << "    Put function ID: ";
    cin >> new_m.id;
    cin.ignore();//Ignores upper cin \n
    cout << endl << "    Put function name: ";
    getline(cin, new_m.name);

    //Verify the input name
    while(check_function_name(new_m.name) != 0){
        cout << endl << "    Put function name: ";
        getline(cin, new_m.name);
    }


    cout << "    	Put the name of the module that this function belongs to: ";
    getline(cin, new_m.module_of_function);

    cout << endl << "    Put function return type: ";
    getline(cin, new_m.return_type);

    cout << endl << "	Put the number of parameters: ";
    cin >> new_m.number_of_parameters;
    cin.ignore();

    //Insert all the parameters
    for(int i = 0; i < new_m.number_of_parameters; i++){
        
        cout <<  endl << "	  Put type of the parameter: ";
        getline(cin, param_type);
        new_m.param_types.push_back(param_type);

        cout << endl << "	Put the name of the parameter: ";
        getline(cin, param_name);
        new_m.param_names.push_back(param_name);
    }

    data_base = fopen(functions_data_base_path.c_str(), "r+b");
    fseek(data_base, (new_m.id-1)*sizeof(code_generator_struct), SEEK_SET);
    fwrite(&new_m, sizeof(code_generator_struct), 1, data_base);
    fclose(data_base);
}

int CodeGenerator::check_function_name(string name){

    for(int i = 0; i < name.length(); i++){
        if(name[i] == '(' || name[i] == ')'){
            cout << "\nInvalid characters: ( or )" << endl;
            return 1;
        }
        if(name[i] == ';'){
            cout << "\nInvalid character: ;" << endl;
            return 1;
        }
        if(name[i] == ' ' && i < name.length()-1){
            cout << "\nInvalid character: space in the name" << endl;
            return 1;
        }
    }

    return 0;

}


void CodeGenerator::console_create_modules_database(){

    code_generator_struct new_f; //Struct that receives new function data
    FILE *data_base; //Pointer to data_base file

    cout << "    Put module ID: ";
    cin >> new_f.id;
    cin.ignore();//Ignores upper cin \n
    cout << endl << "    Put module name: ";
    getline(cin, new_f.name);

    //Verify the input name
    while(check_module_name(new_f.name) != 0){
        cout << endl << "    Put module name: ";
        cin >> new_f.name;
    }

    cout << endl << "    Put module classifier: ";
    getline(cin, new_f.module_classifier);

    data_base = fopen(modules_data_base_path.c_str(), "r+b");
    fseek(data_base, (new_f.id-1)*sizeof(code_generator_struct), SEEK_SET);
    fwrite(&new_f, sizeof(code_generator_struct), 1, data_base);
    fclose(data_base);
}

int CodeGenerator::check_module_name(string name){

    for(int i = 0; i < name.length(); i++){
        if(name[i] == '<' || name[i] == '>'){
            cout << "\nInvalid characters: < or >." << endl;
            return 1;
        }
        if(i < name.length()-1 && name[i] == '.' && name[i+1] == 'h'){
            cout << "\nInvalid characters: .h" << endl;
            return 1;
        }
        if(name[i] == ' ' && i < name.length()-1){
            cout << "\nInvalid characters: space in the name" << endl;
            return 1;
        }
    }

    return 0;

}

int CodeGenerator::console_linear_function(vector<int> id_functions){

    FILE * data_base;
    ofstream code_file;
    string s_functions;
    string linear_functions = "";
    int i = 0;

    data_base = fopen(functions_data_base_path.c_str(), "rb");
    if(data_base != 0){
       while(id_functions[i] != -1){
            fseek(data_base, (id_functions[i]-1)*sizeof(code_generator_struct), SEEK_SET);
            fread(&data_for_functions, sizeof(code_generator_struct), 1, data_base);
            s_functions = data_for_functions.name;
            linear_functions = linear_functions + "\n    ";

            //Write the variables according to the parameters names and types
            //Write parameters
            for(int j = 0; j < data_for_functions.number_of_parameters; j++){
                //Type
                linear_functions =  linear_functions + data_for_functions.param_types[j] + " ";
                //Name
                linear_functions = linear_functions + data_for_functions.param_names[j] + ";\n    ";
            }

            //Write the return variable
            linear_functions = linear_functions + data_for_functions.return_type + " " + data_for_functions.name + "_"
                + "return = ";

            linear_functions = linear_functions + s_functions + "(";

            //Write parameters
            for(int j = 0; j < data_for_functions.number_of_parameters; j++){
                //Name
                linear_functions = linear_functions + data_for_functions.param_names[j];

                if(j < data_for_functions.number_of_parameters - 1){
                    linear_functions = linear_functions + ", ";
                }
            }
            linear_functions = linear_functions + ");\n";

            s_functions = "";
                    i++;
            }
        fclose(data_base);
        cout << linear_functions << endl;
        code_file.open(code_file_name, ios_base::app);
        code_file << linear_functions;
        code_file.close();
    }
    else{
        cout << "Error - Functions data base cannot be opened." << endl;
            return -1;
    }
    return 0;
}

void CodeGenerator::initial_setup(){

    //Starts the generated code file
    ofstream code_file;
    string code;

    //Open the file to append
    code_file.open(code_file_name, ios_base::app);

    code = "\n";
    code = code + "	//Code for the initial setup\n";
    code = code + "	system_init();\n";
    code = code + "	system_config();\n";
    code = code + "\n";

    //Writes to file
    code_file << code;
    code_file.close();
}

//Inteface functions

int CodeGenerator::console_initial_menu(){

    int user_choice;

    //Prints the menu
    system("clear");
    cout << "=================================================" << endl;
    cout << "=              Aker - Code Generator            =" << endl;
    cout << "=================================================" << endl;
    cout << "  Choose an option:                             " << endl;
    cout << "    1. Register a function;                    " << endl;
    cout << "    2. Register a module;                      " << endl;
    cout << "    3. Generate code;                            " << endl;
    cout << "    4. Exit;                                     " << endl;
    cout << "  Your choice: ";

    //Reads the user choice
    cin  >>  user_choice;

    //Updates the class attribute with the user choice
    this->user_choice = user_choice;
}

void CodeGenerator::console_new_function(){

    //Prints the header
    system("clear");
    cout << "=================================================" << endl;
    cout << "=              Aker - Code Generator            =" << endl;
    cout << "=================================================" << endl;

    //Calls the function that creates the functions database
    this->console_create_functions_database();

}

void CodeGenerator::console_new_module(){

    //Prints the interface
    system("clear");
    cout << "=================================================" << endl;
    cout << "=              Aker - Code Generator            =" << endl;
    cout << "=================================================" << endl;

    //Calls the functions that creates the modules database
    this->console_create_modules_database();

}

void CodeGenerator::console_insert_modules(){

    int number_of_modules;
    int module_id;

    //Prints the interface
    system("clear");
    cout << "=================================================" << endl;
    cout << "=              Aker - Code Generator            =" << endl;
    cout << "=================================================" << endl;
    cout << "  How many modules do you want?                  " << endl;

    //Handles the reading of the modules IDs
    cin  >> number_of_modules;

    cout << "  Entry modules IDs:                           " << endl;
    for(int i = 0; i<number_of_modules ; i++){
        cin  >> module_id;

        this->modules_ids.push_back(module_id);

    }

}

void CodeGenerator::console_insert_functions(){

    int number_of_states;
    int number_of_functions;
    int function_id;
    vector<vector<int>> states_functions;

    //Prints the interface for the state machine
    system("clear");
    cout << "=================================================" << endl;
    cout << "=              Aker - Code Generator            =" << endl;
    cout << "=================================================" << endl;
    cout << "  How many states do you want?                  " << endl;

    //Reads the number of states that the program will have
    cin  >> number_of_states;
    this->number_of_states = number_of_states;

    //For each state, read its functions
    for(int i = 0; i<number_of_states ; i++){

        //Prints the interface for adding functions to the states
        system("clear");
        cout << "=================================================" << endl;
        cout << "=              Aker - Code Generator            =" << endl;
        cout << "=================================================" << endl;
        cout << "  How many functions do you want in state " << i << "?" << endl;
        cin  >> number_of_functions;

        //*(states_functions[i] + number_of_functions) = -1;
        cout << "  Entry functions IDs:                           " << endl;

        this->states_functions.push_back(std::vector<int>());
        for(int j = 0; j<number_of_functions ; j++){
            cin  >> function_id; 

            this->states_functions[i].push_back(function_id);

        }
    }


}

void CodeGenerator::ui_initial_menu(int user_choice){
    this->set_user_choice(user_choice);
}

void CodeGenerator::ui_new_function(int function_id, string function_name, string module_of_function, string return_type,
                                                int number_of_parameters, vector<string> param_types_list,
                                                vector<string> param_names_list){

    this->set_function_id(function_id);
    this->set_function_name(function_name);
    this->set_module_of_function(module_of_function);
    this->set_return_type(return_type);
    this->set_number_of_parameters(number_of_parameters);
    this->set_param_types_list(param_types_list);
    this->set_param_names_list(param_names_list);
    this->ui_create_functions_database();

}

void CodeGenerator::ui_new_module(int module_id, string module_name, string module_classifier){

    this->set_module_id(module_id);
    this->set_module_name(module_name);
    this->set_module_classifier(module_classifier);

    this->ui_create_modules_database();
}

void CodeGenerator::ui_insert_modules(int number_of_modules, vector<int> modules_ids){
    this->number_of_modules = number_of_modules;
    this->modules_ids = modules_ids;
}

void CodeGenerator::ui_insert_functions(vector<vector<int>> states_functions){
    /*this->number_of_states = number_of_states;

    this->states_functions = (int **)malloc(this->number_of_states * sizeof(int*));

    for(int i = 0; i < this->number_of_states; i++){
        this->states_functions[i] = (int *)malloc(functions_per_state[i] * sizeof(int));
        for(int j = 0; j < functions_per_state[i] + 1; j++){
            if(j < functions_per_state[i]){
                this->states_functions[i][j] = states_functions[i][j];
            }
            else{
                this->states_functions[i][j] = -1;
            }
        }
    }*/

    this->states_functions = states_functions;
}

void CodeGenerator::ui_create_functions_database(){
    code_generator_struct new_m; //Struct that receives new function data
    FILE *data_base; //Pointer to data_base file

    new_m.id = this->function_id;
    new_m.name = this->function_name;
    new_m.module_of_function = this->module_of_function;
    new_m.return_type = this->return_type;
    new_m.number_of_parameters = this->number_of_parameters;

    for(int i = 0; i < new_m.number_of_parameters; i++){
        new_m.param_types[i] = this->param_types_list[i];
        new_m.param_names[i] = this->param_names_list[i];
    }

    data_base = fopen(functions_data_base_path.c_str(), "r+b");
    if(data_base == NULL){
        data_base = fopen(functions_data_base_path.c_str(), "w+b");
    }
    fseek(data_base, (new_m.id-1)*sizeof(code_generator_struct), SEEK_SET);
    fwrite(&new_m, sizeof(code_generator_struct), 1, data_base);
    fclose(data_base);
}

void CodeGenerator::ui_create_modules_database(){
    code_generator_struct new_f; //Struct that receives new module data
    FILE *data_base; //Pointer to data_base file
    new_f.id = this->module_id;
    
    new_f.name = this->module_name;
    new_f.module_classifier = this->module_classifier;

    data_base = fopen(modules_data_base_path.c_str(), "r+b");
    if(data_base == NULL){
        data_base = fopen(modules_data_base_path.c_str(), "w+b");
    }
    fseek(data_base, (new_f.id-1)*sizeof(code_generator_struct), SEEK_SET);
    fwrite(&new_f, sizeof(code_generator_struct), 1, data_base);
    fclose(data_base);
}

void CodeGenerator::console_generate(){

    //Insert modules
    this->console_insert_modules();

    //Insert functions
    this->console_insert_functions();

    //Starts the code
    this->console_start();

    //Write the  code
    this->console_state_machine_code();

    //Finishes the code
    this->finish();
}

void CodeGenerator::ui_generate(int number_of_modules, vector<int> modules_ids,
     vector<int> functions_per_state, int number_of_states, vector<vector<int>> states_functions){

    //Insert modules
    this->ui_insert_modules(number_of_modules, modules_ids);

    //Insert functions
    this->ui_insert_functions(states_functions);

    //Starts the code
    this->ui_start();

    //Write the  code
    this->ui_state_machine_code();

    //Finishes the code
    this->finish();
}

int CodeGenerator::ui_start(){

    //Starts the generated code file
    ofstream code_file;
    string code;
    FILE * data_base;
    string s_modules;
    string input_modules = "";

    code_file.open(code_file_name);

    code = "//This code was generated by codeGenerator\n";
    //Fist, all the includes should be put here
    code = code + "#include<iostream>\n";

    //Writes to file
    code_file << code;
    code_file.close();

    //Writes the modules chosen by the user
    data_base = fopen(modules_data_base_path.c_str(), "rb");
    if(data_base != 0){
       for(int i = 0; i < this->number_of_modules; i++){
            fseek(data_base, (this->modules_ids[i]-1)*sizeof(code_generator_struct), SEEK_SET);
            fread(&data_for_modules, sizeof(code_generator_struct), 1, data_base);
            s_modules = data_for_modules.name;
            input_modules = input_modules + "\n";
            input_modules = input_modules + "#include<" +s_modules + ".h>";
            s_modules = "";            }
        fclose(data_base);
        cout << input_modules << endl;
        code_file.open(code_file_name, ios_base::app);
        code_file << input_modules + "\n\n";
        code_file.close();
    }
    else{
        cout << "Error - Modules data base cannot be opened." << endl;
            return -1;
    }

    code_file.open(code_file_name, ios_base::app);

    //Namespace std, default in c++ applications
    code = "using namespace std;\n\n";
    //Starts the main function
    code = code + "int main(){\n";
    //Code....

    //Writes to file
    code_file << code;
    code_file.close();
}

int CodeGenerator::ui_state_machine_code(){
    //Opens the file
    ofstream code_file;
    string code;
    code_file.open(code_file_name, ios_base::app);

    //Initializes a state machine var
    code = "//State Machine state\n";
    code += "int state = 0;\n\n";

    //Opens the state machine
    code += "switch(state){\n";

    //writes to the file
    code_file << code;

    //You need to close the file before call a function that opens it
    code_file.close();

    //For each state, calls the linear_function to write it's respective functions
    for(int i = 0; i < this->number_of_states; i++){

        code_file.open(code_file_name, ios_base::app);

        //Another state
        code = "\n	case '" + to_string(i) + "':\n";

        //writes to the file
        code_file << code;

        //You need to close the file before call a function that opens it
        code_file.close();

        //Write the linear code state
        this->ui_linear_function(this->states_functions[i]);
    }

    //Opens the file
    code_file.open(code_file_name, ios_base::app);

    //Close the switch
    code = "\n    }\n";

    //writes to the file
    code_file << code;
    //You need to close the file before call a function that opens it
    code_file.close();

    return 0;
}

int CodeGenerator::ui_linear_function(vector<int> id_functions){

    FILE * data_base;
    ofstream code_file;
    string s_functions;
    string linear_functions = "";
    int i = 0;

    data_base = fopen(functions_data_base_path.c_str(), "rb");
    if(data_base != 0){
       while(id_functions[i] != -1){
            fseek(data_base, (id_functions[i]-1)*sizeof(code_generator_struct), SEEK_SET);
            fread(&data_for_functions, sizeof(code_generator_struct), 1, data_base);
            s_functions = data_for_functions.name;
            linear_functions = linear_functions + "\n    ";

            //Write the variables according to the parameters names and types
            //Write parameters
            for(int j = 0; j < data_for_functions.number_of_parameters; j++){
                //Type
                linear_functions =  linear_functions + data_for_functions.param_types[j] + " ";
                //Name
                linear_functions = linear_functions + data_for_functions.param_names[j] + ";\n    ";
            }

            //Write the return variable
            linear_functions = linear_functions + data_for_functions.return_type + " " + data_for_functions.name + "_"
                + "return = ";

            linear_functions = linear_functions + s_functions + "(";

            //Write parameters
            for(int j = 0; j < data_for_functions.number_of_parameters; j++){
                //Name
                linear_functions = linear_functions + data_for_functions.param_names[j];

                if(j < data_for_functions.number_of_parameters - 1){
                    linear_functions = linear_functions + ", ";
                }
            }
            linear_functions = linear_functions + ");\n";

            s_functions = "";
                    i++;
            }
        fclose(data_base);
        cout << linear_functions << endl;
        code_file.open(code_file_name, ios_base::app);
        code_file << linear_functions;
        code_file.close();
    }
    else{
        cout << "Error - Functions data base cannot be opened." << endl;
            return -1;
    }
    return 0;
}

    //Setters
void CodeGenerator::set_user_choice(int user_choice){
    this->user_choice = user_choice;
}

void CodeGenerator::set_modules_ids(vector<int> modules_ids){
    this->modules_ids = modules_ids;
}

void CodeGenerator::set_number_of_states(int number_of_states){
    this->number_of_states = number_of_states;
}

void CodeGenerator::set_states_functions(vector<vector<int>> states_functions){
    this->states_functions = states_functions;
}

void CodeGenerator::set_function_id(int function_id){
    this->function_id = function_id;
}

void CodeGenerator::set_function_name(string function_name){
    this->function_name = function_name;
}

void CodeGenerator::set_return_type(string return_type){
    this->return_type = return_type;
}

void CodeGenerator::set_number_of_parameters(int number_of_parameters){
    this->number_of_parameters = number_of_parameters;
}

void CodeGenerator::set_param_types_list(vector<string> param_types_list){
    this->param_types_list = param_types_list;
}

void CodeGenerator::set_param_names_list(vector<string> param_names_list){
    this->param_names_list = param_names_list;
}

void CodeGenerator::set_module_id(int module_id){
    this->module_id = module_id;
}

void CodeGenerator::set_module_name(string module_name){
    this->module_name = module_name;
}

void CodeGenerator::set_number_of_modules(int number_of_modules){
    this->number_of_modules = number_of_modules;
}

void CodeGenerator::set_module_classifier(string classifier){
    this->module_classifier = classifier;
}

void CodeGenerator::set_module_of_function(string module_of_function){
    this->module_of_function = module_of_function;
}

//Gettes
int CodeGenerator::get_user_choice(){
    return this->user_choice;
}

vector<int> CodeGenerator::get_modules_ids(){
    return this->modules_ids;
}

int CodeGenerator::get_number_of_states(){
    return this->number_of_states;
}

vector<vector<int>> CodeGenerator::get_states_functions(){
    return this->states_functions;
}

int CodeGenerator::get_function_id(){
    return this->function_id;
}

string CodeGenerator::get_function_name(){
    return this->function_name;
}

string CodeGenerator::get_return_type(){
    return this->return_type;
}

int CodeGenerator::get_number_of_parameters(){
    return this->number_of_parameters;
}

vector<string> CodeGenerator::get_param_types_list(){
    vector<string> param_types_list;

    //for(int i = 0; i < this->number_of_parameters; i++){
    //    param_types_list.push_back(this->param_types_list[i]);
    //}
    return this->param_types_list;
}

vector<string> CodeGenerator::get_param_names_list(){
    vector<string> param_names_list;

    //for(int i = 0; i < this->number_of_parameters; i++){
    //    param_names_list.push_back(this->param_names_list[i]);
    //}
    return this->param_names_list;
}

int CodeGenerator::get_module_id(){
    return this->module_id;
}

string CodeGenerator::get_module_name(){
    return this->module_name;
}

int CodeGenerator::get_number_of_modules(){
    return this->number_of_modules;
}

string CodeGenerator::get_module_classifier(){
    return this->module_classifier;
}

string CodeGenerator::get_module_of_function(){
    return this->module_of_function;
}


vector<string> CodeGenerator::get_all_modules_names_by_classifier(string classifier){

    FILE * data_base;
    vector<string> modules_names;

    data_base = fopen(modules_data_base_path.c_str(), "rb");
    if(data_base != NULL){

        fseek(data_base, 0L, SEEK_END);
        int sz = ftell(data_base);
        fseek(data_base, 0L, SEEK_SET);

        for(int i = 0; i < sz/sizeof(code_generator_struct); i++){
            fseek(data_base, i*sizeof(code_generator_struct), SEEK_SET);
            fread(&data_for_modules, sizeof(code_generator_struct), 1, data_base);
            if(data_for_modules.module_classifier.compare(classifier) == 0 && data_for_modules.id != 0){
                modules_names.push_back(data_for_modules.name);
            }
        }

        fclose(data_base);
    }

    return modules_names;
}

vector<string> CodeGenerator::get_all_functions_of_a_module(string module_name){

    FILE * data_base;
    vector<string> function_names;

    data_base = fopen(functions_data_base_path.c_str(), "rb");
    if(data_base != NULL){

        fseek(data_base, 0L, SEEK_END);
        int sz = ftell(data_base);
        fseek(data_base, 0L, SEEK_SET);

        for(int i = 0; i < sz/sizeof(code_generator_struct); i++){
            fseek(data_base, i*sizeof(code_generator_struct), SEEK_SET);
            fread(&data_for_functions, sizeof(code_generator_struct), 1, data_base);
            if(data_for_functions.module_of_function.compare(module_name)==0 && data_for_functions.id != 0){
                function_names.push_back(data_for_functions.name);
            }
        }

        fclose(data_base);
    }

    return function_names;
}

int CodeGenerator::get_function_id_by_name(string function_name){
    FILE * data_base;
    int id = -1;

    data_base = fopen(functions_data_base_path.c_str(), "rb");
    if(data_base != NULL){

        fseek(data_base, 0L, SEEK_END);
        int sz = ftell(data_base);
        fseek(data_base, 0L, SEEK_SET);

        for(int i = 0; i < sz/sizeof(code_generator_struct); i++){
            fseek(data_base, i*sizeof(code_generator_struct), SEEK_SET);
            fread(&data_for_functions, sizeof(code_generator_struct), 1, data_base);
            if(data_for_functions.name.compare(function_name)==0){
                return data_for_functions.id;
            }
        }

        fclose(data_base);
    }

    return id;
}

int CodeGenerator::get_module_id_by_name(string module_name){
    FILE * data_base;
    int id = -1;

    data_base = fopen(modules_data_base_path.c_str(), "rb");
    if(data_base != NULL){

        fseek(data_base, 0L, SEEK_END);
        int sz = ftell(data_base);
        fseek(data_base, 0L, SEEK_SET);

        for(int i = 0; i < sz/sizeof(code_generator_struct); i++){
            fseek(data_base, i*sizeof(code_generator_struct), SEEK_SET);
            fread(&data_for_modules, sizeof(code_generator_struct), 1, data_base);
            if(data_for_modules.name.compare(module_name)==0){
                return data_for_modules.id;
            }
        }

        fclose(data_base);
    }

    return id;
}

//Initializes the state machine counter
int CodeGenerator::curr_state_number = 0;
